# -*- coding: utf-8 -*-
"""Final Forse Code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oAbnnM0Rrc99Pz58SxZYuShRJNCcdwSV

Analysis of long cycling linear
"""

import numpy as np            #necessary initialisation stuff
import matplotlib.pyplot as plt
from scipy.stats import linregress
pathway=input('what is the pathway? (when you upload the file, right click and copy path) ')
currentdensity=input('what is the current density in A/g? ')
currentdensity=float(currentdensity)
current=float(input('what is the mass of the electrode in mg? '))*currentdensity*0.001
cycles=int(input('How many cycles have you inputted? '))
peakvoltage=float(input('what is the peak voltage? e.g. O.8V 1.0V? '))
steps=int(input('How many steps in the gradient would you like to take? '))



time=np.array(np.genfromtxt(pathway, usecols=0)) #takes the data from the text files and stores it
voltage=np.array(np.genfromtxt(pathway, usecols=1)) #takes the data from the text files and stores it
uneditedtime=time       #the time array will be edited and cut off along the way in the code. Unedited time will stay the same.
uneditedvoltage=voltage   #the voltage array will be edited and cut off along the way in the code. Unedited voltage will stay the same.
size=np.prod(time.shape) #size of the array, will be used later on a lot (how many data points)
dVdt= []
#need to now differentiate between vertical and diagonal line
#use derivatives
#use a loop
for j in np.arange(1,size//steps, 1): #calculates gradient every 'steps' number of points
  derivative=(voltage[steps*j]-voltage[steps*(j-1)])/(time[steps*j]-time[steps*(j-1)])
  dVdt.append(derivative)
#the loop above works out the derivative between every 'steps' points and adds it to an array called dVdt which stores all the gradients
plt.plot(time,voltage)
plt.xlabel('Time/s')
plt.ylabel('Voltage/V')
plt.title('GCD you inputted') #plots the GCD
plt.show()
lengthofdVdt=len(dVdt)
remainder= np.prod(time.shape) % steps    #let's say you take every 5 points but you have 7 points overall. This removes the last 2 points temporarily so that the gradient can be plotted
if remainder>0:
    remaindertime=time[:-remainder]
else:
    remaindertime=time
gradtime=remaindertime[::steps]
plt.plot(gradtime[:-1],dVdt)
plt.xlabel('Time/s')
plt.ylabel('Rate of change of Voltage/Vs\u207b\u00b9 ')
plt.title('dVdt graph for whole GCD')     #plots the gradient function over the whole GCD
plt.show()
dischargev = {}   #messy array stuff.. dischargev,t,dVdt stores the full discharge curve for every cycle. Verticalv,t,dVdt stores every vertical section for every cycle
discharget = {}   #diagonalv,t,dVdt stores every diagonal section for every cycle (voltage, time and rate of change in voltage(dV/dt))
dischargedVdt = {}
verticaldVdt = {}
verticalt = {}
verticalv= {}
diagonaldVdt = {}
diagonalt = {}
diagonalv= {}
capacity = {}   #will store capacity for every cycle number
capacitance= {}
IRdrop= {}
ESR = {}
i2=0
for cyclenumber in np.arange(0, cycles, 1): #repeats for every cycle
    dVdt = dVdt[i2:]
    time = time[steps * i2:]
    voltage = voltage[steps * i2:]
    investigate = dVdt[:lengthofdVdt // (cycles + 1)]
    i = np.argmin(investigate)      #removes any charging and a bit of the voltage drop, makes it easier to find the end of the voltage drop

    voltage = voltage[steps * (i):] #edits the voltage to remove the charging part
    time = time[steps * (i):]
    dVdt = dVdt[i:]

    for i2, loop in enumerate(dVdt):  # removes any of the charging part that may come after the diagonal line
        if i2 >= (len(dVdt)-1) or loop > 0.00:
            dischargev[cyclenumber] = voltage[:steps * (i2)]
            discharget[cyclenumber] = time[:steps * (i2)]
            dischargedVdt[cyclenumber] = dVdt[:i2]
            break
    temporaryv = dischargev[cyclenumber]
    temporaryt = discharget[cyclenumber]
    temporarydVdt = dischargedVdt[cyclenumber]
    threshold = np.mean(temporarydVdt)
    for i1, loop in enumerate(temporarydVdt): #finds the end of the voltage drop by finding when the gradient goes above the mean
        if 0 > loop > threshold:
            index = i1
            break
    verticaldVdt[cyclenumber] = temporarydVdt[:index]
    verticalt[cyclenumber] = temporaryt[:steps * index]
    verticalv[cyclenumber]= temporaryv[:steps * index]
    diagonaldVdt[cyclenumber] = temporarydVdt[index:]
    diagonalt[cyclenumber] = temporaryt[steps * index:]
    diagonalv[cyclenumber] = temporaryv[steps * index:]
    temporaryt=diagonalt[cyclenumber]
    temporaryv=diagonalv[cyclenumber]
    vertical = temporaryv[0]  #end of vertical IR drop
    slope, intercept, _, _, _ = linregress(diagonalt[cyclenumber], diagonalv[cyclenumber]) #works out slope of discharge and therefore the capacitance

    capacity[cyclenumber] = 0.5 * currentdensity * (temporaryt[-1] - temporaryt[0])  #works out capacity
    capacitance[cyclenumber]= -2 * currentdensity / slope
    IRdrop[cyclenumber]= peakvoltage - vertical
    ESR[cyclenumber]= (peakvoltage - vertical) / (2 * current)

capacity_values=list(capacity.values())
capacitance_values = list(capacitance.values())
cycle_numbers = list(capacitance.keys())
IRdrop_values = list(IRdrop.values())
ESR_values= list(ESR.values())

#plots Capacitance against cycle number
plt.plot(cycle_numbers, capacitance_values)
plt.xlabel('Cycle number')
plt.ylabel('Gravimetric Capacitance F/g')
plt.title('Capacitance against cycle number')
#plt.savefig(input('What do you want to save the Capacitance against cycle number graph as? Do not forget to add .png at the end '), dpi=300)
plt.show()

#plots ESR plot against cycle number
plt.plot(cycle_numbers,ESR_values)
plt.title('ESR against cyclenumber in Î©')
#plt.savefig(input('What do you want to save the ESR against cycle number graph as? Do not forget to add .png at the end '), dpi=300)
plt.show()

#plots capacity against cycle number
plt.plot(cycle_numbers,capacity_values)
plt.title('Capacity against cyclenumber')
#plt.savefig(input('What do you want to save the Capacity against cycle number graph as? Do not forget to add .png at the end '), dpi=300)
plt.show()


print('mean capacitance across all cycles is ',np.mean(capacitance_values))
print('mean IR drop across all cycles is ', np.mean(IRdrop_values), ' and the mean ESR is ', np.mean(ESR_values))
print('mean Capacity across all cycles is ',np.mean(capacity_values))

"""The below code gives a text file of every Capacity/Capacitance and IR drop value for each cycle."""

data = np.array(list(zip(cycle_numbers, capacitance_values, capacity_values, IRdrop_values, ESR_values)),
                dtype=[('Cycle Number', int), ('Capacitance', float), ('Capacity', float), ('IR Drop', float), ('ESR', float)])

# Save the structured array to a text file
np.savetxt(input('What is the name of the text file you want to save the analysis results in? Do not forget to add .txt please. '), data, delimiter='\t', fmt='%d\t%.4f\t%.4f\t%.4f\t%.4f', header='Cycle Number\tCapacitance\tCapacity\tIR Drop\tESR', comments='')

"""For non linear analysis, run the code above then this code below. It will give the full discharge and the linear regression discharge as according to the literature (all excluding IR drop)"""

import numpy as np            #necessary initialisation stuff
import matplotlib.pyplot as plt
from scipy.stats import linregress
pathway=input('what is the pathway? (when you upload the file, right click and copy path) ')
currentdensity=input('what is the current density in A/g? ')
currentdensity=float(currentdensity)
current=float(input('what is the mass of the electrode in mg? '))*currentdensity*0.001
cycles=int(input('How many cycles have you inputted? '))
peakvoltage=float(input('what is the peak voltage? e.g. O.8V 1.0V? '))
steps=1



time=np.array(np.genfromtxt(pathway, usecols=0)) #takes the data from the text files and stores it
voltage=np.array(np.genfromtxt(pathway, usecols=1)) #takes the data from the text files and stores it
uneditedtime=time       #the time array will be edited and cut off along the way in the code. Unedited time will stay the same.
uneditedvoltage=voltage   #the voltage array will be edited and cut off along the way in the code. Unedited voltage will stay the same.
size=np.prod(time.shape) #size of the array, will be used later on a lot (how many data points)
dVdt= []
#need to now differentiate between vertical and diagonal line
#use derivatives
#use a loop
for j in np.arange(1,size//steps, 1): #calculates gradient every 'steps' number of points
  derivative=(voltage[steps*j]-voltage[steps*(j-1)])/(time[steps*j]-time[steps*(j-1)])
  dVdt.append(derivative)
#the loop above works out the derivative between every 'steps' points and adds it to an array called dVdt which stores all the gradients
plt.plot(time,voltage)
plt.xlabel('Time/s')
plt.ylabel('Voltage/V')
plt.title('GCD you inputted') #plots the GCD
plt.show()
lengthofdVdt=len(dVdt)
remainder= np.prod(time.shape) % steps    #let's say you take every 5 points but you have 7 points overall. This removes the last 2 points temporarily so that the gradient can be plotted
if remainder>0:
    remaindertime=time[:-remainder]
else:
    remaindertime=time
gradtime=remaindertime[::steps]
plt.plot(gradtime[:-1],dVdt)
plt.xlabel('Time/s')
plt.ylabel('Rate of change of Voltage/Vs\u207b\u00b9 ')
plt.title('dVdt graph for whole GCD')     #plots the gradient function over the whole GCD
plt.show()
dischargev = {}   #messy array stuff.. dischargev,t,dVdt stores the full discharge curve for every cycle. Verticalv,t,dVdt stores every vertical section for every cycle
discharget = {}   #diagonalv,t,dVdt stores every diagonal section for every cycle (voltage, time and rate of change in voltage(dV/dt))
dischargedVdt = {}
verticaldVdt = {}
verticalt = {}
verticalv= {}
diagonaldVdt = {}
diagonalt = {}
diagonalv= {}
capacity = {}   #will store capacity for every cycle number
capacitance= {}
linearcapacitance= {}
fullcapacitance= {}
IRdrop= {}
ESR = {}
i2=0
for cyclenumber in np.arange(0, cycles, 1):
    dVdt = dVdt[i2:]
    time = time[steps * i2:]
    voltage = voltage[steps * i2:]
    investigate = dVdt[:lengthofdVdt // (cycles + 1)]
    i = np.argmin(investigate)

    voltage = voltage[steps * (i):]
    time = time[steps * (i):]
    dVdt = dVdt[i:]

    for i2, loop in enumerate(dVdt):  # removes any of the charging part that may come after the diagonal line
        if i2 >= (len(dVdt)-1) or loop > 0.00:
            dischargev[cyclenumber] = voltage[:steps * (i2)]
            discharget[cyclenumber] = time[:steps * (i2)]
            dischargedVdt[cyclenumber] = dVdt[:i2]
            break

    temporaryv = dischargev[cyclenumber]
    temporaryt = discharget[cyclenumber]
    temporarydVdt = dischargedVdt[cyclenumber]
    threshold = np.mean(temporarydVdt)
    for i1, loop in enumerate(temporarydVdt):
        if 0 > loop > threshold:
            index = i1
            break
    verticaldVdt[cyclenumber] = temporarydVdt[:i1]
    verticalt[cyclenumber] = temporaryt[:steps * i1]
    verticalv[cyclenumber]= temporaryv[:steps * i1]
    diagonaldVdt[cyclenumber] = temporarydVdt[i1:]
    diagonalt[cyclenumber] = temporaryt[steps * i1:]
    diagonalv[cyclenumber] = temporaryv[steps * i1:]
    temporaryt=diagonalt[cyclenumber]
    temporaryv=diagonalv[cyclenumber]
    vertical = temporaryv[0]
    slope, intercept, _, _, _ = linregress(diagonalt[cyclenumber], diagonalv[cyclenumber])

    capacity[cyclenumber] = 0.5 * currentdensity * (temporaryt[-1] - temporaryt[0])
    capacitance[cyclenumber]= -2 * currentdensity / slope
    IRdrop[cyclenumber]= peakvoltage - vertical
    ESR[cyclenumber]= (peakvoltage - vertical) / (2 * current)
    diagonalx=diagonalt[cyclenumber]
    diagonaly=diagonalv[cyclenumber]
    fullcapacitance[cyclenumber]=-2*currentdensity*(diagonalx[-1]-diagonalx[0])/(diagonaly[-1]-diagonaly[0])






capacity_values=list(capacity.values())
capacitance_values = list(capacitance.values())
cycle_numbers = list(capacitance.keys())
IRdrop_values = list(IRdrop.values())
ESR_values= list(ESR.values())
fullcapacitance_values= list(fullcapacitance.values())
plt.plot(cycle_numbers, capacitance_values)
plt.xlabel('Cycle number')
plt.ylabel('Capacitance (F/g)')
plt.title('Linear regression Capacitance against cycle number')
plt.show()
plt.plot(cycle_numbers,ESR_values)
plt.title('Irdrop against cyclenumber')
plt.xlabel('Cycle number')
plt.ylabel('IR drop (V)')
plt.show()
plt.plot(cycle_numbers,capacity_values)
plt.title('Capacity against cyclenumber')
plt.xlabel('Cycle number')
plt.ylabel('Capacity (C/g)')
plt.show()
plt.plot(cycle_numbers,fullcapacitance_values)
plt.title('Full discharge Capacitance against cyclenumber')
plt.xlabel('Cycle number')
plt.ylabel('Capacitance (F/g)')
plt.show()
print('mean capacitance across all cycles is ',np.mean(capacitance_values))
print('mean Full discharge capacitance across all cycles is ',np.mean(fullcapacitance_values))
print('mean IR drop across all cycles is ', np.mean(IRdrop_values), ' and the mean ESR is ', np.mean(ESR_values))
print('mean Capacity across all cycles is ',np.mean(capacity_values))

"""The below code gives a text file of every Capacity/Capacitance and IR drop value for each cycle."""

data = np.array(list(zip(cycle_numbers, capacitance_values, capacity_values, IRdrop_values, ESR_values, fullcapacitance_values)),
                dtype=[('Cycle Number', int), ('Capacitance', float), ('Capacity', float), ('IR Drop', float), ('ESR', float), ('full discharge capacitance', float)])

# Save the structured array to a text file
np.savetxt(input('What is the name of the text file you want to save the analysis results in? Do not forget to add .txt please. '), data, delimiter='\t', fmt='%d\t%.4f\t%.4f\t%.4f\t%.4f', header='Cycle Number\tCapacitance\tCapacity\tIR Drop\tESR\tFull discharge Capacitance', comments='')

"""Analysis for multiple current densities"""

import numpy as np            #necessary initialisation stuff
import matplotlib.pyplot as plt
from scipy.stats import linregress
pathway=input('what is the pathway? (when you upload the file, right click and copy path) ')
mass=float(input('what is the mass of the electrode in mg? '))
howmanycurrent=int(input('How many current densities are you testing? '))
currentdensity= {}
for currentdensitynum in np.arange(0,howmanycurrent,1):
    currentdensity[currentdensitynum]=float(input(f'What is current density number {currentdensitynum+1}? '))
cycles=int(input('How many cycles per current density have you inputted? '))
peakvoltage=float(input('what is the peak voltage? e.g. O.8V 1.0V? '))
steps=int(input('How many steps in the gradient would you like to take? '))



time=np.array(np.genfromtxt(pathway, usecols=0)) #takes the data from the text files and stores it
voltage=np.array(np.genfromtxt(pathway, usecols=1)) #takes the data from the text files and stores it
uneditedtime=time       #the time array will be edited and cut off along the way in the code. Unedited time will stay the same.
uneditedvoltage=voltage   #the voltage array will be edited and cut off along the way in the code. Unedited voltage will stay the same.
plt.plot(time,voltage)
plt.title('GCD you inputted')
plt.show()
Agtime = {}
Agvoltage= {}

indices=np.where(np.isclose(voltage, 0.00015, atol=0.0002))
indices=indices[0]
print(indices)
tolerance = 20


# Set the tolerance for similarity
tolerance = 20

# Create a set to keep track of values to remove
values_to_remove = set()

# Compare each value with the others
for i, value1 in enumerate(indices):
    for j, value2 in enumerate(indices):
        if i != j and np.isclose(value1, value2, atol=tolerance):
            # Values are similar, mark one for removal
            values_to_remove.add(min(value1, value2))

# Filter the values to keep only those not in the values_to_remove set
filtered_values = np.array([value for value in indices if value not in values_to_remove])

print(filtered_values, 'length is', len(filtered_values))

size=np.prod(time.shape) #size of the array, will be used later on a lot (how many data points)
dVdt= []
#need to now differentiate between vertical and diagonal line
#use derivatives
#use a loop
for j in np.arange(1,size//steps, 1): #calculates gradient every 'steps' number of points
  derivative=(voltage[steps*j]-voltage[steps*(j-1)])/(time[steps*j]-time[steps*(j-1)])
  dVdt.append(derivative)
remainder= np.prod(time.shape) % steps    #let's say you take every 5 points but you have 7 points overall. This removes the last 2 points temporarily so that the gradient can be plotted
if remainder>0:
    remaindertime=time[:-remainder]
else:
    remaindertime=time
gradtime=remaindertime[::steps]
plt.plot(gradtime[:-1],dVdt)
plt.xlabel('Time/s')
plt.ylabel('Rate of change of Voltage/Vs\u207b\u00b9 ')
plt.title('dVdt graph for whole GCD')     #plots the gradient function over the whole GCD
plt.show()
fulltime= {}
fullvoltage= {}
fulldVdt= {}
currentdensitynum=0
n=0
for cyclenumber in np.arange(0,len(filtered_values),1):
    if cyclenumber==0:
        fulltime[cyclenumber]=time[:filtered_values[0]]
        fullvoltage[cyclenumber]=voltage[:filtered_values[0]]
        fulldVdt[cyclenumber]=dVdt[:(filtered_values[0]//steps)]
    else:
        fulltime[cyclenumber]=time[filtered_values[cyclenumber-1]:filtered_values[cyclenumber]]
        fullvoltage[cyclenumber]=voltage[filtered_values[cyclenumber-1]:filtered_values[cyclenumber]]
        fulldVdt[cyclenumber]=dVdt[(filtered_values[cyclenumber-1]//steps):(filtered_values[cyclenumber]//steps)]
dischargev = {}   #messy array stuff.. dischargev,t,dVdt stores the full discharge curve for every cycle. Verticalv,t,dVdt stores every vertical section for every cycle
discharget = {}   #diagonalv,t,dVdt stores every diagonal section for every cycle (voltage, time and rate of change in voltage(dV/dt))
dischargedVdt = {}
verticaldVdt = {}
verticalt = {}
verticalv= {}
diagonaldVdt = {}
diagonalt = {}
diagonalv= {}
capacity = {}   #will store capacity for every cycle number
capacitance= {}
linearcapacitance= {}
fullcapacitance= {}
IRdrop= {}
ESR = {}
for cyclenumber in np.arange(0,len(filtered_values),1):
    temporarydVdt=fulldVdt[cyclenumber]
    temporaryt=fulltime[cyclenumber]
    temporaryv=fullvoltage[cyclenumber]
    i = np.argmin(temporarydVdt)

    temporaryv = temporaryv[steps * (i):]
    temporaryt = temporaryt[steps * (i):]
    temporarydVdt = temporarydVdt[i:]

    dischargev[cyclenumber]=temporaryv
    discharget[cyclenumber]=temporaryt
    dischargedVdt[cyclenumber] = temporarydVdt
    threshold = np.mean(temporarydVdt)
    for i1, loop in enumerate(temporarydVdt):
        if 0 > loop > threshold:
            index = i1
            break
    verticaldVdt[cyclenumber] = temporarydVdt[:i1]
    verticalt[cyclenumber] = temporaryt[:steps * i1]
    verticalv[cyclenumber]= temporaryv[:steps * i1]
    diagonaldVdt[cyclenumber] = temporarydVdt[i1:]
    diagonalt[cyclenumber] = temporaryt[steps * i1:]
    diagonalv[cyclenumber] = temporaryv[steps * i1:]
    temporaryt=diagonalt[cyclenumber]
    temporaryv=diagonalv[cyclenumber]
    vertical = temporaryv[0]
    slope, intercept, _, _, _ = linregress(diagonalt[cyclenumber], diagonalv[cyclenumber])
    if n==cycles:
        n=0
        currentdensitynum=currentdensitynum+1
    capacity[cyclenumber] = 0.5 * currentdensity[currentdensitynum] * (temporaryt[-1] - temporaryt[0])
    capacitance[cyclenumber]= -2 * currentdensity[currentdensitynum] / slope
    IRdrop[cyclenumber]= peakvoltage - vertical
    ESR[cyclenumber]= (peakvoltage - vertical) / (2 * currentdensity[currentdensitynum]*mass)
    diagonalx=diagonalt[cyclenumber]
    diagonaly=diagonalv[cyclenumber]
    fullcapacitance[cyclenumber]=-2*currentdensity[currentdensitynum]*(diagonalx[-1]-diagonalx[0])/(diagonaly[-1]-diagonaly[0])
    n=n+1
capacity_values=np.array(list(capacity.values()))
capacitance_values=np.array(list(capacitance.values()))
fullcapacitance_values=np.array(list(fullcapacitance.values()))
IRdrop_values = np.array(list(IRdrop.values()))
ESR_values=np.array(list(ESR.values()))
capacity_values = capacity_values.reshape(howmanycurrent, cycles)
mean_capacity = np.mean(capacity_values, axis=1)
capacitance_values = capacitance_values.reshape(howmanycurrent, cycles)
mean_capacitance = np.mean(capacitance_values, axis=1)
fullcapacitance_values = fullcapacitance_values.reshape(howmanycurrent, cycles)
mean_fullcapacitance = np.mean(fullcapacitance_values, axis=1)
currentdensityarray=np.array(list(currentdensity.values()))
plt.plot(currentdensityarray,mean_capacity)
plt.xlabel('Current density A/g')
plt.ylabel('Capacity C/g')
plt.title('Capacity against current density')
plt.show()
plt.plot(currentdensityarray,mean_capacitance)
plt.xlabel('Current density A/g')
plt.ylabel('Capacitance F/g')
plt.title('Capacitance against current density')
plt.show()
plt.plot(currentdensityarray,mean_fullcapacitance)
plt.xlabel('Current density A/g')
plt.ylabel('Full Capacitance C/g')
plt.title('Full Capacitance against current density')
plt.show()

"""Additional tool to merge text files together for multiple current densities... I don't know if there is a way to do it on EC-lab so I had to do it using this code..."""

import numpy as np

def join_text_files(file_paths, output_filename):
    combined_data = []

    for col in range(2):  # Loop through both columns
        column_data = []
        for file_path in file_paths:
            data = np.genfromtxt(file_path, usecols=col)  # Load data from the current column
            column_data.append(data)

        combined_column = np.concatenate(column_data, axis=0)  # Combine column data vertically
        combined_data.append(combined_column)

    combined_data = np.column_stack(combined_data)  # Combine the two columns side by side

    np.savetxt(output_filename, combined_data, delimiter='  ')
    print(f"Text files successfully joined and saved as {output_filename}")

# Prompt user for input
num_files = int(input("Enter the number of text files you want to join: "))
file_paths = []
for i in range(num_files):
    file_path = input(f"Enter the path of text file {i + 1}: ")
    file_paths.append(file_path)

output_file = input("Enter the name of the output file: ")

join_text_files(file_paths, output_file)